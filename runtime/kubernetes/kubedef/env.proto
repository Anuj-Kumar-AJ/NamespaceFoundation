// Copyright 2022 Namespace Labs Inc; All rights reserved.
// Licensed under the EARLY ACCESS SOFTWARE LICENSE AGREEMENT
// available at http://github.com/namespacelabs/foundation

syntax = "proto3";

package foundation.runtime.kubernetes.kubedef;

option go_package = "namespacelabs.dev/foundation/runtime/kubernetes/kubedef";

import "schema/binary.proto";
import "schema/package.proto";
import "std/runtime/config.proto";
import "std/runtime/deployable.proto";
import "std/types/certificates.proto";

message SpecExtension {
    // XXX ideally we'd use Kubernetes protos here.
    string              service_account = 3;
    repeated Volume     volume          = 1;
    repeated Annotation annotation      = 2;
    // If true, creates a service account. If `service_account` is specified, use that name, else generate one from the server's name.
    bool                ensure_service_account     = 4;
    repeated Annotation service_account_annotation = 5;
    SecurityContext     security_context           = 6;

    message Volume {
        string name = 1;

        oneof volume_type {
            Secret    secret     = 2;
            ConfigMap config_map = 3;
        }

        message Secret {
            string secret_name = 1;
        }

        message ConfigMap {
            string        name            = 1;
            string        config_map_name = 2;
            repeated Item item            = 3;

            message Item {
                string key  = 1;
                string path = 2;
            }
        }
    }

    message Annotation {
        string key   = 1;
        string value = 2;
    }

    message SecurityContext {
        int64 run_as_user  = 1;
        int64 run_as_group = 2;
        int64 fs_group     = 3;
    }
}

// Next ID: 7
message ContainerExtension {
    repeated VolumeMount volume_mount          = 1;
    repeated schema.BinaryConfig.EnvEntry env  = 2;
    repeated string                       args = 5;

    // Deprecated, use `args`.
    repeated ArgTuple arg_tuple = 4;
    // Deprecated, use `InitContainerExtension`.
    repeated InitContainer init_container = 3;

    repeated Probe probe = 6;

    message VolumeMount {
        string name          = 1;
        bool   read_only     = 2;
        string mount_path    = 3;
        bool   mount_on_init = 4;  // Whether to mount this volume also for init containers.
    }

    message Env {
        string name  = 1;
        string value = 2;
    }

    message ArgTuple {
        string name  = 1;
        string value = 2;
    }

    message InitContainer {
        string          package_name = 1;
        repeated string arg          = 2;
    }

    message Probe {
        string kind           = 1;
        string path           = 2;
        int32  container_port = 3;
    }
}

message InitContainerExtension {
    // Deprecated, use package_ref.
    string package_name = 1;

    schema.PackageRef package_ref = 3;

    repeated string args = 2;
}

message OpApply {
    reserved 6;

    string                   body_json                  = 4;
    bool                     set_namespace              = 8;
    CheckGenerationCondition check_generation_condition = 7;
    bool                     inhibit_events             = 9;

    message CheckGenerationCondition {
        string type = 1;
    }

    reserved 1, 2, 3, 5;
}

message OpEnsureRuntimeConfig {
    string                    config_id      = 1;
    std.runtime.Deployable    deployable     = 2;
    std.runtime.RuntimeConfig runtime_config = 3;
    repeated string           resource_id    = 4;
}

message OpDelete {
    reserved 4;

    string resource      = 1;
    string namespace     = 2;
    bool   set_namespace = 5;
    string name          = 3;
}

message OpDeleteList {
    reserved 4;

    string resource       = 1;
    string namespace      = 2;
    bool   set_namespace  = 5;
    string label_selector = 3;
}

message OpCreate {
    reserved 7;
    string resource               = 1;  // XXX deprecated.
    bool   set_namespace          = 8;
    bool   skip_if_already_exists = 2;
    bool   update_if_existing     = 6;
    string body_json              = 5;

    reserved 3, 4;
}

// This is a temporary type; usage should be limited. It's a workaround until we
// can compose invocations, so secrets can wrap a "create secret payload"
// invocation around the user-provided invocation. The value is passed
// along-side the SerializedInvocation, with key "value".
message OpCreateSecretConditionally {
    reserved 5;
    string namespace                                                = 1;
    bool                                    set_namespace           = 6;
    string                                  name                    = 2;
    string                                  user_specified_name     = 3;
    foundation.std.types.TLSCertificateSpec self_signed_certificate = 4;
}

message OpCleanupRuntimeConfig {
    string namespace = 1;
    bool check_pods  = 2;  // Set in tests.
}

message OpApplyRoleBinding {
    bool              namespaced        = 1;
    string            role_name         = 2;
    string            role_binding_name = 3;
    repeated KeyValue label             = 4;
    repeated KeyValue annotation        = 5;
    string            rules_json        = 6;
    string            service_account   = 7;

    message KeyValue {
        string key   = 1;
        string value = 2;
    }
}